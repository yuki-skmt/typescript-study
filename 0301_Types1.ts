namespace AnyType {
    /*=================================================
     *【any型】
     * ・型がわからない場合にデフォルトで割り当てられる型。
     * ・「全て」の値の集合であり、「何でも」行うことができる。
     * 　→型安全性を保証するために極力使用するべきではない。
     *================================================*/
    // エラーにならない
    let a: any = 666;
    let b: any = ['danger'];
    let c = a + b; // !!!
}

namespace UnknownType {
    /*=================================================
     *【unknown型】
     * ・anyと同様に、任意の値を表す。
     * ・型の絞り込みを行うまで、使用が許可されない。
     *================================================*/
    let a: unknown;
    // 絞り込み前なのでエラーになる
    //a + 2;

    let b: unknown = 1;
    if (typeof b === 'number') {
        // 絞り込み後なのでエラーにならない
        b + 2;
    }
}

namespace BooleanType {
    /*=================================================
     *【boolean型】
     * ・true/falseからなる。
     * ・比較ができる。(==, ===, ||, &&, ?)
     * ・否定ができる。(!)
     *================================================*/
    // 推論可能
    let a = true;
    var b = false;
    const c = true;

    // 明示的に示すことができる
    let d: boolean = true;

    // 特定のbooleanであることを示すことができる
    let e: true = true;

    // エラー：特定のboolean型にはそれ以外割当不可
    //let f: true = false;
}

namespace NumberType {
    /*=================================================
     *【number型】
     * ・整数、浮動小数点数、正数、負数、無限大(Infinity)、非数(NaN)などの集まり。
     * ・加算(+)、減算(-)、余剰(%)、比較(<)などができる。
     *================================================*/
    // 推論可能
    let a = 1234;
    var b = Infinity * 0.1;
    const c = 5678;

    // 比較可能(boolean)
    let d = a < b;

    // 明示的に示すことができる
    let e: number = 100;

    // 特定の値であることを示すことができる
    let f: 26.218 = 26.218;

    // エラー：特定のnumber型にはそれ以外割当不可
    //let g: 26.218 = 10;
}

namespace BigintType {
    /*=================================================
     *【bigint型】
     * ・numberの上限(2^53)より大きい値も含めた、正数の集まり。
     * ・加算(+)、減算(-)、乗算(*)、除算(/)、比較(<)などができる。
     *================================================*/
    // 推論可能
    let a = 1234n;
    const b = -5678n;
    var c = a + b;

    // 比較可能(boolean)
    let d = a < 1235;

    // エラー：少数は割当不可
    //let e = 88.5n;

    // 明示的に示すことができる
    let f: bigint = 100n;

    // 特定の値であることを示すことができる
    let g: 100n = 100n;

    // エラー：number型のリテラルは割当不可
    //let h: bigint = 100;
}

namespace StringType {
    /*=================================================
     *【string型】
     * ・全ての文字列の集まり。
     * ・連結(+)、スライス(.slice)などができる。
     *================================================*/
    // 推論可能
    let a = 'hello';
    var b = 'billy';
    const c = '!';
    let d = a + ' ' + b + c;

    // 明示的に示すことができる
    let e: string = 'zoom';

    // 明示的に示すことができる
    let f: 'john' = 'john';

    // エラー：特定のstring型にはそれ以外割当不可。
    //let g: 'john' = 'zoe';
}

namespace SymbolType {
    /*=================================================
     *【symbol型】
     * ・常に一意の値を返す。
     * ・文字列キーの代替となる。
     *
     *【unique symbol型】
     * ・symbol型をconstに割り当てる場合、unique symbolと推論される。
     * ・常にそれ自身と等しくなる。
     * ・常に他のunique symbolと等しくならない。
     *================================================*/
    // 推論可能
    let a = Symbol('a');
    let b: symbol = Symbol('b');

    // 比較可能(常にfalse)
    var c = a === b;

    // エラー：割当不可。
    //let d = a + 'x';

    // unique symbol
    const e = Symbol('e');
    const f: unique symbol = Symbol('f');

    // エラー：const以外では割当不可
    //let g: unique symbol = Symbol('f');

    // 常にtrueを返す
    let h = e === e;

    // エラー：常にfalseを返す
    //let i = e === f;
}

namespace ObjectType {
    /*=================================================
     *【object型】
     * ・オブジェクトの形状を指定できる。
     * ・構造的型付け(not 名前的型付け)される。
     * 　→型付けの上では何のプロパティを持つかが重要で、その名前は重要ではない。
     * ・宣言時、objectで型を明示しない。オブジェクトリテラル表記で型推論させる。
     *================================================*/
    // 悪い例
    let a: object = {
        b: 'x',
    };
    // エラー
    //a.b

    // 良い例：オブジェクトリテラル
    let c = {
        d: 'x',
    };
    // エラーではない
    c.d;

    // constでもletと同様に型推論される(特定の値で型付けされるわけではない)
    // { f: string }
    const e = {
        f: 'x',
    };
}
